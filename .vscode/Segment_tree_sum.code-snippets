{
  "find sum[L,R] or update arr[pos]=val in array": {
    "prefix": "segment_tree_sum",
    "body": [
      "//0-base: parent->P, L->2*P+1, R->2*P+2",
      "//1-base: parent->P, L->2*P, R->2*P+1",
      "",
      "vl arr(N),tree(4*N);",
      "",
      "//1 base index of tree and array",
      "void build_segment_tree (ll idx,ll st, ll en){",
      "    if(st==en) {tree[idx]=arr[st];return;}",
      "    ll mid=(st+en)/2;",
      "    build_segment_tree(2*idx,st,mid);",
      "    build_segment_tree(2*idx+1,mid+1,en);",
      "    tree[idx]=tree[2*idx]+tree[2*idx+1];",
      "}",
      "",
      "ll query(ll idx,ll st,ll en,ll l, ll r){",
      "    if(en<l || r<st) return 0;",
      "    if(st>=l && en<=r) return tree[idx];",
      "    ll mid=(st+en)/2;",
      "    ll L=query(2*idx,st,mid,l,r);",
      "    ll R=query(2*idx+1,mid+1,en,l,r);",
      "    return L+R;",
      "}",
      "",
      "void update(ll idx,ll st,ll en,ll pos,ll val){",
      "    if(st==en) {tree[idx]=val;return;}",
      "    ll mid=(st+en)/2;",
      "    if(pos<=mid) update(2*idx,st,mid,pos,val);",
      "    else update(2*idx+1,mid+1,en,pos,val);",
      "    tree[idx]=tree[2*idx]+tree[2*idx+1];",
      "}",
      "",
      "    // f(i,1,n+1) cin>>arr[i];",
      "    // build_segment_tree(1,1,n);",
      "    // ll ans=query(1,1,n,l,r);",
      "    // update(1,1,n,pos,val);",
      "",
      ""
    ],
    "description": "find sum[L,R] or update arr[pos]=val in array"
  }
}